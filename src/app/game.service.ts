import { Injectable } from '@angular/core';
import { AngularFirestore } from '@angular/fire/compat/firestore';
import { BehaviorSubject } from 'rxjs';
import { Question } from './customquestion.service';

export interface Player {
  id: string; // Unique identifier for the player (generated by Firestore or another method)
  name: string;
  score: number; 
  timestamp: Date;
  lastanswertimestamp: Date;
  isCorrect: boolean;
}

export interface GameData {
  questions: Question[];
  players: Player[];
  gameState: string;
  currentQuestionIndex: number;
  roundNumber: number;
}

interface QuestionSet {
  questions: Question[];
}


@Injectable({
  providedIn: 'root'
})

export class GameService {

  private gameId: string ='';
  private questions: Question[] = [];
  private players: Player[] = [];
  private currentQuestionIndex: number = 0;
  private roundNumber: number = 1;
  private gameState: string = 'stopped'; // 'started', 'stopped', 'paused'

  // Observable to manage game state changes
  gameStateSubject = new BehaviorSubject<string>(this.gameState);
  gameState$ = this.gameStateSubject.asObservable();

  constructor(private firestore: AngularFirestore) {}

  // Create a new game with a specified question set ID
  async createNewGame(questionSetId: string): Promise<void> {
    this.gameId = this.firestore.createId(); // Generate a unique game ID
    this.questions = await this.loadQuestions(questionSetId);

    // Set up initial game state in Firestore
    await this.firestore.collection('games').doc(this.gameId).set({
      questionSetId: questionSetId,
      gameState: 'stopped',
      players: [],
      currentQuestionIndex: 0,
      roundNumber: 1,
      // ... (other game data)
    });
  }
  // Join a game using the game ID
  async joinGame(gameId: string, playerName: string): Promise<void> {
    this.gameId = gameId;
  
    try {
      // Load game state and questions from Firestore
      const gameDoc = await this.firestore.collection('games').doc(this.gameId).get().toPromise();
  
      if (gameDoc && gameDoc.exists) {
        const gameData = gameDoc.data() as GameData;
  
        this.questions = gameData.questions || [];
        this.players = gameData.players || [];
        this.gameState = gameData.gameState || 'stopped';
        this.currentQuestionIndex = gameData.currentQuestionIndex || 0;
        this.roundNumber = gameData.roundNumber || 1;
  
        // Add the player to the game (update Firestore)
        const newPlayerId = this.firestore.createId();
        const newPlayer: Player = { 
          id: newPlayerId, 
          name: playerName, 
          score: 0, 
          timestamp: new Date(), 
          lastanswertimestamp: new Date(), 
          isCorrect: false 
        };
        this.players.push(newPlayer);
  
        await this.firestore.collection('games').doc(this.gameId).update({
          players: this.players
        });
      } else {
        throw new Error(`Game with ID ${this.gameId} does not exist.`);
      }
    } catch (error) {
      console.error("Error joining the game: ", error);
    }
  }
  



  // Start a new round
  async startRound() {
    // If game is not started, do nothing 
    if (this.gameState !== 'stopped') return; 

    this.gameState = 'started';
    this.currentQuestionIndex = 0; 
    this.roundNumber++;

    // Update game state in Firestore
    await this.firestore.collection('games').doc(this.gameId).update({
      gameState: 'started',
      currentQuestionIndex: 0,
      roundNumber: this.roundNumber
    });

    this.gameStateSubject.next(this.gameState);
  }


  // Advance to the next question 
  async nextQuestion() {
    // Check for the end of the round
    if (this.currentQuestionIndex >= this.questions.length - 1) {
      // Trigger end of round actions
      this.gameState = 'stopped';
      await this.firestore.collection('games').doc(this.gameId).update({
        gameState: 'stopped',
        currentQuestionIndex: 0, // Reset to the first question
      });
      this.gameStateSubject.next(this.gameState);
      return;
    } 

    this.currentQuestionIndex++;

    // Update game state in Firestore
    await this.firestore.collection('games').doc(this.gameId).update({
      currentQuestionIndex: this.currentQuestionIndex 
    });
  }

  // Handle player answers
  async submitAnswer(playerId: string, answer: string) {
    const isCorrect = this.questions[this.currentQuestionIndex].answer === answer;

    this.players = this.players.map(p => {
      if (p.id === playerId) {
        return { ...p, score: isCorrect ? p.score + 1 : p.score, lastanswertimestamp: new Date(), isCorrect: isCorrect };
      } else {
        return p;
      }
    });

    // Update player score in Firestore
    await this.firestore.collection('games').doc(this.gameId).update({
      players: this.players
    });
  }

  // Pause the game
  async pauseGame() {
    this.gameState = 'paused';
    // Update game state in Firestore to 'paused'
    await this.firestore.collection('games').doc(this.gameId).update({
      gameState: 'paused'
    });
    this.gameStateSubject.next(this.gameState);
  }

  // Resume the game
  async resumeGame() {
    this.gameState = 'started';
    // Update game state in Firestore to 'started'
    await this.firestore.collection('games').doc(this.gameId).update({
      gameState: 'started'
    });
    this.gameStateSubject.next(this.gameState);
  }

  // Get current question
  getCurrentQuestion(): Question {
    return this.questions[this.currentQuestionIndex];
  }

  // Get current round number
  getCurrentRound(): number {
    return this.roundNumber;
  }

  // Get all players 
  getPlayers(): Player[] {
    return this.players;
  }

  // Load questions from Firestore (you've already implemented this in CustomQuestionService)
  private async loadQuestions(questionSetId: string): Promise<Question[]> {
    const docRef = this.firestore.collection('questionSets').doc(questionSetId);
    const docSnapshot = await docRef.get().toPromise();
  
    if (docSnapshot && docSnapshot.exists) {
      const questionSet = docSnapshot.data() as QuestionSet;
      return questionSet.questions || [];
    } else {
      throw new Error(`Question set with ID ${questionSetId} not found`);
    }
  }
  
}
